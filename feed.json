{
    "version": "https://jsonfeed.org/version/1",
    "title": "Camelot Operating System",
    "description": "",
    "home_page_url": "https://camelot-os.h2lab.org",
    "feed_url": "https://camelot-os.h2lab.org/feed.json",
    "user_comment": "",
    "icon": "https://camelot-os.h2lab.org/media/website/camelot-OS.png",
    "author": {
        "name": "H2Lab Development Team"
    },
    "items": [
        {
            "id": "https://camelot-os.h2lab.org/why-formal-verification-matters-in-the-sentry-microkernel/",
            "url": "https://camelot-os.h2lab.org/why-formal-verification-matters-in-the-sentry-microkernel/",
            "title": "Why Formal Verification Matters in the Sentry Microkernel",
            "summary": "Micro-kernels such as Sentry aim to provide strong isolation, minimal trusted computing bases, and high assurance for embedded and security-critical systems. However, achieving these goals in practice is difficult: subtle bugs in low-level code, memory protection, or context switching can completely undermine the intended security&hellip;",
            "content_html": "<p data-start=\"335\" data-end=\"677\">Micro-kernels such as <strong data-start=\"356\" data-end=\"366\">Sentry</strong> aim to provide strong isolation, minimal trusted computing bases, and high assurance for embedded and security-critical systems. However, achieving these goals in practice is difficult: subtle bugs in low-level code, memory protection, or context switching can completely undermine the intended security model.</p>\n<p data-start=\"679\" data-end=\"984\">This is where <strong data-start=\"693\" data-end=\"716\">formal verification</strong> becomes a decisive advantage. In Sentry, formal methods are not an afterthought or an academic exercise‚Äîthey directly shape the kernel‚Äôs architecture and implementation, particularly in security-critical subsystems such as <strong data-start=\"940\" data-end=\"983\">MPU (Memory Protection Unit) management</strong>.</p>\n<h2 data-start=\"991\" data-end=\"1039\">What Does Formal Verification Mean in Sentry?</h2>\n<p data-start=\"1041\" data-end=\"1411\">Formal verification consists in specifying the intended behavior of the kernel precisely and <strong data-start=\"1134\" data-end=\"1160\">mathematically proving</strong> that the implementation satisfies those specifications. In Sentry, this approach is applied using static analysis and formally-grounded tools (like <strong data-start=\"1309\" data-end=\"1320\">Frama-C</strong>), letting us establish strong guarantees about memory safety, isolation, and control flow.</p>\n<p data-start=\"1413\" data-end=\"1606\">Unlike testing, which can only demonstrate the presence of bugs in specific test cases, formal verification can prove the <strong data-start=\"1535\" data-end=\"1574\">absence of entire classes of errors</strong> across all possible executions.</p>\n<h2 data-start=\"1613\" data-end=\"1643\">Security by Construction</h2>\n<p data-start=\"1645\" data-end=\"1835\">The kernel is the most privileged component of any system. A single flaw can compromise all applications running on top of it. Formal verification helps Sentry address this risk at its root:</p>\n<ul data-start=\"1837\" data-end=\"2124\">\n<li data-start=\"1837\" data-end=\"1897\">\n<p data-start=\"1839\" data-end=\"1897\">It proves that critical invariants hold in all executions.</p>\n</li>\n<li data-start=\"1898\" data-end=\"2027\">\n<p data-start=\"1900\" data-end=\"2027\">It eliminates classes of bugs such as invalid memory accesses, inconsistent state transitions, or broken isolation assumptions.</p>\n</li>\n<li data-start=\"2028\" data-end=\"2124\">\n<p data-start=\"2030\" data-end=\"2124\">It provides <em data-start=\"2042\" data-end=\"2066\">mathematical assurance</em> that the verified properties hold for all possible paths.</p>\n</li>\n</ul>\n<p data-start=\"2126\" data-end=\"2286\">This level of assurance is particularly relevant for embedded and cyber-physical systems, where failures can have safety, financial, or regulatory consequences.</p>\n<h2 data-start=\"2293\" data-end=\"2334\">A Kernel Designed for Verifiability</h2>\n<p data-start=\"2336\" data-end=\"2392\">Formal verification strongly influences Sentry‚Äôs design:</p>\n<ul data-start=\"2394\" data-end=\"2646\">\n<li data-start=\"2394\" data-end=\"2461\">\n<p data-start=\"2396\" data-end=\"2461\"><strong data-start=\"2396\" data-end=\"2424\">Highly modular structure</strong>, enabling component-level reasoning.</p>\n</li>\n<li data-start=\"2462\" data-end=\"2544\">\n<p data-start=\"2464\" data-end=\"2544\"><strong data-start=\"2464\" data-end=\"2497\">Clear and explicit interfaces</strong>, which can be formally specified and verified.</p>\n</li>\n<li data-start=\"2545\" data-end=\"2646\">\n<p data-start=\"2547\" data-end=\"2646\"><strong data-start=\"2547\" data-end=\"2589\">Minimal and encapsulated assembly code</strong>, reducing the unverified surface and simplifying proofs.</p>\n</li>\n</ul>\n<p data-start=\"2648\" data-end=\"2822\">In Sentry, the kernel is not merely verified after implementation; it is <strong data-start=\"2721\" data-end=\"2750\">designed to be verifiable</strong>, which significantly lowers the cost and complexity of formal analysis.</p>\n<h2 data-start=\"2829\" data-end=\"2889\">MPU Management: A Concrete Case of Formal Verification</h2>\n<p data-start=\"2891\" data-end=\"3001\">One of the most compelling applications of formal verification in Sentry is the <strong data-start=\"2971\" data-end=\"3000\">management of MPU regions</strong>.</p>\n<p data-start=\"3003\" data-end=\"3271\">On ARM Cortex-M microcontrollers, the MPU is the primary hardware mechanism used to enforce memory isolation between tasks. Any mistake in MPU configuration can lead to severe vulnerabilities: unintended memory access, privilege escalation, or cross-task interference.</p>\n<p data-start=\"3273\" data-end=\"3348\">Sentry treats MPU management as a first-class, formally reasoned subsystem.</p>\n<h2 data-start=\"4649\" data-end=\"4701\">Example ACSL Specifications for MPU Invariants</h2>\n<p data-start=\"4703\" data-end=\"4962\">Below are example fragments in the style of <strong data-start=\"4747\" data-end=\"4791\">ACSL (ANSI/ISO C Specification Language)</strong> that express core invariants used in Sentry‚Äôs MPU management logic. These are <em data-start=\"4870\" data-end=\"4884\">illustrative</em>, reflecting how formal annotations in <code data-start=\"4923\" data-end=\"4938\">mpu_pmsa_v8.h</code> specify key guarantees.</p>\n<h3 data-start=\"4703\" data-end=\"4962\">About MPU mapping and W^X</h3>\n<p data-start=\"708\" data-end=\"798\">On ARMv8-M the PMSAv8 MPU region validity predicate (in ACSL) says a region is <em data-start=\"787\" data-end=\"794\">valid</em> if:</p>\n<ul data-start=\"800\" data-end=\"984\">\n<li data-start=\"800\" data-end=\"876\">\n<p data-start=\"802\" data-end=\"876\">both base and limit are aligned to the MPU region alignment (<code data-start=\"863\" data-end=\"873\">32 bytes</code>)</p>\n</li>\n<li data-start=\"877\" data-end=\"900\">\n<p data-start=\"879\" data-end=\"900\">the limit is ‚â• base</p>\n</li>\n<li data-start=\"901\" data-end=\"984\">\n<p data-start=\"903\" data-end=\"984\">OR if the region is empty (RBAR/RLAR = 0)</p>\n</li>\n</ul>\n<p data-start=\"986\" data-end=\"1062\">That last point makes ‚Äúunmapped‚Äù regions represent no actual memory mapping.</p>\n<p data-start=\"1064\" data-end=\"1140\">The architecture imposes <em data-start=\"1089\" data-end=\"1108\">Write-xor-Execute</em> semantics via these properties:</p>\n<ol data-start=\"1142\" data-end=\"1665\">\n<li data-start=\"1142\" data-end=\"1238\">\n<p data-start=\"1145\" data-end=\"1238\"><strong data-start=\"1145\" data-end=\"1202\">Executable permissions are encoded in the RBAR XN bit</strong> ‚Äî <code data-start=\"1205\" data-end=\"1218\">noexec == 1</code> ‚Üí non-executable.</p>\n</li>\n<li data-start=\"1239\" data-end=\"1306\">\n<p data-start=\"1242\" data-end=\"1306\"><strong data-start=\"1242\" data-end=\"1303\">Access permission (AP) bits define read/write constraints</strong>.</p>\n</li>\n<li data-start=\"1307\" data-end=\"1665\">\n<p data-start=\"1310\" data-end=\"1442\">The Cortex-M PMSAv8 (as profiled in the kernel header) includes <strong data-start=\"1374\" data-end=\"1388\">assertions</strong> that enforce W^X semantics when forging a resource:</p>\n<ul data-start=\"1446\" data-end=\"1665\">\n<li data-start=\"1446\" data-end=\"1546\">\n<p data-start=\"1448\" data-end=\"1546\">if <code data-start=\"1451\" data-end=\"1464\">noexec == 0</code> (i.e., region is executable), then the access permission must be RO (read-only)</p>\n</li>\n<li data-start=\"1550\" data-end=\"1665\">\n<p data-start=\"1552\" data-end=\"1665\">conversely, if the region is writable (non-RO), then <code data-start=\"1605\" data-end=\"1613\">noexec</code> must be set</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 data-start=\"4964\" data-end=\"4998\">Region-related predicates</h3>\n<p data-start=\"5000\" data-end=\"5098\">A set of predicates has been written to verify region properties, including PMSAv8 conformity and overlapping check to already mapped regions.</p>\n<div class=\"contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary\">¬†</div>\n<div class=\"absolute end-0 bottom-0 flex h-9 items-center pe-2\">\n<div class=\"bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs\">\n<pre class=\"language-c\"><code>/*@\n\n  predicate aligned_32(‚Ñ§ addr) =\n    (addr &amp; MPU_REGION_ALIGN_MASK) == 0;\n\n    predicate mpu_is_empty_region(ARM_MPU_Region_t r1) =\n      r1.RBAR == 0 &amp;&amp; r1.RLAR == 0;\n\n  predicate valid_mpu_region(‚Ñ§ base, ‚Ñ§ limit) =\n    ((base == 0 &amp;&amp; limit == 0) ||\n    (\n        aligned_32(base)\n        &amp;&amp; aligned_32(limit)\n        &amp;&amp; limit &gt;= base\n        &amp;&amp; ((limit - base + 1) % MPU_REGION_ALIGN == 0)\n    ));\n\n  predicate valid_mpu_regions{L}(ARM_MPU_Region_t *regions, integer n) =\n        \\forall integer i;\n            0 &lt;= i &lt; n ==&gt;\n            valid_mpu_region(regions[i].RBAR &amp; MPU_RBAR_BASE_Msk,\n                             regions[i].RLAR &amp; MPU_RLAR_LIMIT_Msk);\n\n  predicate non_empty_region(‚Ñ§ base, ‚Ñ§ limit) =\n    (limit - base + 1) &gt;= MPU_REGION_ALIGN;\n\n  // when either region is empty, they are considered disjoint\n  predicate disjoint(ARM_MPU_Region_t r1, ARM_MPU_Region_t r2) =\n      r1.RBAR == 0 &amp;&amp; r1.RLAR == 0 ||\n      r2.RBAR == 0 &amp;&amp; r2.RLAR == 0 ||\n      (\n        (r1.RBAR &amp; MPU_RBAR_BASE_Msk) &lt;= (r2.RLAR &amp; MPU_RLAR_LIMIT_Msk) ||\n        (r2.RBAR &amp; MPU_RBAR_BASE_Msk) &lt;= (r1.RLAR &amp; MPU_RLAR_LIMIT_Msk)\n      );\n\n  predicate regions_disjoint{L}(ARM_MPU_Region_t *regions, integer n) =\n      \\forall integer i, j;\n        0 &lt;= i &lt; n &amp;&amp; 0 &lt;= j &lt; n &amp;&amp; i != j ==&gt;\n          disjoint(regions[i], regions[j]);\n*/\n</code></pre>\n</div>\n</div>\n<p data-start=\"5473\" data-end=\"5500\">These predicates then need to be added as pre and postconditions of programs that are responsible for manpulatin task memory regions.<br>This is done using a single primitive in the kernel, that add a new region to a given task region set. This primitive is denoted <span style=\"font-size: inherit;\"><code>mgr_task_add_resource()</code>.</span></p>\n<h3 data-start=\"5565\" data-end=\"5593\">Region validity check</h3>\n<pre class=\"language-c\"><code>kstatus_t status;\ntask_t *cell;\n\n// [...]\nif (unlikely(mpu_region_is_valid(&amp;resource) == SECURE_FALSE)) {\n        status = K_ERROR_INVPARAM;\n        goto err;\n}\n/* demonstrate that the effective run time check does match the predicate */\n/*@ assert valid_mpu_regions(&amp;resource, 1); */</code></pre>\n<h3 data-start=\"5565\" data-end=\"5593\">Non-Overlapping check</h3>\n<p data-start=\"5595\" data-end=\"5643\">In this function, the overlapping check is made using disjoint assertion between all the existing regions of the task and the new one that aim to be added:</p>\n<pre class=\"language-c\"><code>/*@ ghost int is_disjoint = 0; */\n/*@\n      loop invariant 0 &lt;= idx &lt;= TASK_MAX_RESSOURCES_NUM;\n      loop invariant \\initialized(&amp;cell-&gt;layout[idx]);\n      loop assigns idx;\n      loop variant TASK_MAX_RESSOURCES_NUM - idx;\n */\nfor (uint8_t idx = 0; idx &lt; TASK_MAX_RESSOURCES_NUM; ++idx) {\n    if (unlikely(mpu_regions_overlap(cell-&gt;layout[idx], resource) == SECURE_TRUE)) {\n        status = K_ERROR_INVPARAM;\n        /*@ ghost is_disjoint = 1; */\n        goto err;\n    }\n    /*@ assert disjoint(cell-&gt;layout[idx], resource); */\n}</code></pre>\n<h3 data-start=\"6104\" data-end=\"6133\">Context Switch</h3>\n<p data-start=\"6135\" data-end=\"6209\">At context switch, the above updated table is the lonely one used in order to map the newly scheduled task, meaning that this table is the single source of memoyr mapping configuration. This is why the lonely table writter is stricty verified.</p>\n<div class=\"contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary\">¬†</div>\n<h2 data-start=\"1872\" data-end=\"1904\">How Frama-C coverage is used</h2>\n<p data-start=\"1906\" data-end=\"1949\">Frama-C is called using both EVA and WP plugins through the following entrypoint:</p>\n<div class=\"contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary\">¬†</div>\n<div class=\"absolute end-0 bottom-0 flex h-9 items-center pe-2\">\n<div class=\"bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs\">\n<pre class=\"language-c\"><code>int map_resource(void)\n{\n    /*\n     * here we define unpredictable resource ID and layout,\n     * to cover any possible resource structure input values, so\n     * that we can demonstrate that only valid (aligned, non-overlapping)\n     * resources are mapped.\n     * NOTE: this do not check the resource ownership, as this is done by\n     * the task manager itself.\n     */\n    volatile uint8_t resource_id = 0;\n    volatile layout_resource_t resource;\n    /*\n     * call kernel startup up to task manager initialisation. This part noRTE has already\n     * been demonstrated in another Frama-C test that targets kernel entrypoint directly\n     */\n    if (prepare_startup() != 0) {\n        return -1;\n    }\n    /* as we do not check ownership but only mapping, we use idle task as vehicle */\n    mgr_task_add_resource(mgr_task_get_idle(), resource_id, resource);\n    return 0;\n}</code></pre>\n</div>\n</div>\n<p data-start=\"2028\" data-end=\"2033\">This entrypoint has¬† the following properties:</p>\n<ul data-start=\"2035\" data-end=\"2264\">\n<li data-start=\"2035\" data-end=\"2096\">\n<p data-start=\"2037\" data-end=\"2096\"><code data-start=\"2037\" data-end=\"2050\">resource_id</code> <em data-start=\"2051\" data-end=\"2066\">unconstrained</em> (volatile nondeterministic)</p>\n</li>\n<li data-start=\"2097\" data-end=\"2163\">\n<p data-start=\"2099\" data-end=\"2163\"><code data-start=\"2099\" data-end=\"2109\">resource</code> <em data-start=\"2110\" data-end=\"2125\">unconstrained</em> (volatile full <code data-start=\"2141\" data-end=\"2160\">layout_resource_t</code>)</p>\n</li>\n<li data-start=\"2164\" data-end=\"2264\">\n<p data-start=\"2166\" data-end=\"2264\">no precondition on the shape of the descriptor or its fields</p>\n</li>\n</ul>\n<p data-start=\"2266\" data-end=\"2376\"><strong data-start=\"2266\" data-end=\"2279\">Important</strong>: the test does <em data-start=\"2295\" data-end=\"2300\">not</em> assume anything about <code data-start=\"2323\" data-end=\"2333\">resource</code> ‚Äî it may hold any bit pattern. That means:</p>\n<ul data-start=\"2378\" data-end=\"2764\">\n<li data-start=\"2378\" data-end=\"2518\">\n<p data-start=\"2380\" data-end=\"2518\">Frama-C‚Äôs WP plugin generates obligations for <em data-start=\"2426\" data-end=\"2440\">all possible</em> values of the <code data-start=\"2455\" data-end=\"2474\">layout_resource_t</code> inputs passed to <code data-start=\"2492\" data-end=\"2515\">mgr_task_add_resource</code>.</p>\n</li>\n<li data-start=\"2519\" data-end=\"2673\">\n<p data-start=\"2521\" data-end=\"2673\">As part of the manager implementation, <code data-start=\"2560\" data-end=\"2583\">mgr_task_add_resource</code> will <strong data-start=\"2589\" data-end=\"2614\">forge an MPU resource</strong> using the kernel‚Äôs internal data and architecture model.</p>\n</li>\n<li data-start=\"2674\" data-end=\"2764\">\n<p data-start=\"2676\" data-end=\"2764\">The forging logic includes those important W^X assertions inside <code data-start=\"2741\" data-end=\"2761\">mpu_forge_resource</code>.</p>\n</li>\n</ul>\n<p data-start=\"2766\" data-end=\"2939\">Because those assertions are in the <em data-start=\"2802\" data-end=\"2830\">resource construction code</em>, the only way for the overall proof to succeed for <em data-start=\"2882\" data-end=\"2932\">every nondeterministic input resource descriptor</em> is if:</p>\n<ol data-start=\"2941\" data-end=\"3278\">\n<li data-start=\"2941\" data-end=\"3110\">\n<p data-start=\"2944\" data-end=\"3110\"><strong data-start=\"2944\" data-end=\"3019\">invalid region configurations are either rejected or proven unreachable</strong> ‚Äî i.e., they violate <code data-start=\"3041\" data-end=\"3062\">mpu_region_is_valid</code> or internal access-permission invariants; and</p>\n</li>\n<li data-start=\"3111\" data-end=\"3278\">\n<p data-start=\"3114\" data-end=\"3278\"><strong data-start=\"3114\" data-end=\"3277\">only valid MPU regions that satisfy alignment, size, and access permission constraints (including W^X) can ever flow into the low-level MPU configuration logic</strong>.</p>\n</li>\n</ol>\n<p data-start=\"3280\" data-end=\"3556\">Frama-C tries to discharge all obligations (e.g., prove no runtime errors, prove postconditions, prove assertions). If any possible value could produce a region that violates W^X (e.g., writable and executable), the corresponding WP proof obligation <em data-start=\"3530\" data-end=\"3555\">would not be discharged</em>.</p>\n<p data-start=\"3558\" data-end=\"3563\">Thus:</p>\n<p data-start=\"3565\" data-end=\"3921\">‚úî The test <em data-start=\"3576\" data-end=\"3610\">covers all possible bit patterns</em> for <code data-start=\"3615\" data-end=\"3625\">resource</code><br data-start=\"3625\" data-end=\"3628\">‚úî The proof infrastructure uses <code data-start=\"3660\" data-end=\"3681\">mpu_region_is_valid</code> to <em data-start=\"3685\" data-end=\"3727\">reject invalid base/limit configurations</em> via its ACSL predicate in <code data-start=\"3754\" data-end=\"3769\">mpu_pmsa_v8.h</code></p>\n<p data-start=\"3923\" data-end=\"3980\">When launched, the <strong data-start=\"3930\" data-end=\"3959\">Frama-C test demonstrates</strong> the W^X property by:</p>\n<ul data-start=\"3982\" data-end=\"4272\">\n<li data-start=\"3982\" data-end=\"4122\">\n<p data-start=\"3984\" data-end=\"4122\">constraining the set of acceptable region configurations to only those where <strong data-start=\"4061\" data-end=\"4115\">write and execute are not simultaneously permitted</strong>; and</p>\n</li>\n<li data-start=\"4123\" data-end=\"4272\">\n<p data-start=\"4125\" data-end=\"4272\">ensuring that any path through <code data-start=\"4156\" data-end=\"4179\">mgr_task_add_resource</code> that could lead to invalid combinations <em data-start=\"4220\" data-end=\"4271\">cannot happen under the ACSL and proof conditions</em>.</p>\n</li>\n</ul>\n<p>Test results show that Frama-C is able to demonstrate that all assertions and obligations are valid, whatever the input is, and as such demonstrate the effective W^X property.</p>\n<h2 data-start=\"7318\" data-end=\"7331\">Conclusion</h2>\n<p data-start=\"7333\" data-end=\"7540\">Sentry demonstrates that formal verification is not an abstract academic ideal, but a <strong data-start=\"7419\" data-end=\"7449\">practical engineering tool</strong> for building secure micro-kernels. Nowhere is this more concrete than in its MPU subsystem:</p>\n<ul data-start=\"7542\" data-end=\"7716\">\n<li data-start=\"7542\" data-end=\"7607\">\n<p data-start=\"7544\" data-end=\"7607\">Memory isolation is backed by mathematically proven invariants.</p>\n</li>\n<li data-start=\"7608\" data-end=\"7658\">\n<p data-start=\"7610\" data-end=\"7658\">Subtle, low-level bugs are eliminated by design.</p>\n</li>\n<li data-start=\"7659\" data-end=\"7716\">\n<p data-start=\"7661\" data-end=\"7716\">Security properties are guaranteed rather than assumed.</p>\n</li>\n</ul>\n<p data-start=\"7718\" data-end=\"7876\">By integrating formal methods into both architecture and implementation, Sentry raises the bar for what it means to be ‚Äúsecure by design‚Äù in embedded systems.</p>",
            "author": {
                "name": "H2Lab Development Team"
            },
            "tags": [
            ],
            "date_published": "2026-01-18T08:58:13+01:00",
            "date_modified": "2026-01-30T18:45:04+01:00"
        },
        {
            "id": "https://camelot-os.h2lab.org/exploring-pointer-free-data-exchange-in-sentry/",
            "url": "https://camelot-os.h2lab.org/exploring-pointer-free-data-exchange-in-sentry/",
            "title": "Exploring Pointer-Free Data Exchange in Sentry",
            "summary": "When diving into Sentry-micro-kernel concepts, one design choice really stood out: no pointer passing between user space and kernel space. Instead of relying on pointers, Sentry uses a dedicated buffer called svc_exchange to transfer data between applications and the kernel. This simple but powerful approach:&hellip;",
            "content_html": "<p><span class=\"break-words\n          tvm-parent-container\"><span dir=\"ltr\">When diving into Sentry-micro-kernel concepts, one design choice really stood out: no pointer passing between user space and kernel space.<br>Instead of relying on pointers, Sentry uses a dedicated buffer called svc_exchange to transfer data between applications and the kernel.<br>This simple but powerful approach:<br>üîí Strengthens security (no unsafe pointer dereferencing)<br>üìê Simplifies formal verification<br>‚ö° Keeps the kernel lightweight and predictable<br><br>Here is how this pointer-free exchange model works, its strengths, limitations, and what it means for developers.<br>üëâ Key takeaway: sometimes removing a feature (pointers) is the best way to reduce complexity and improve system robustness. This is a key design being a balance between security, simplicity, and performance in kernel‚Äìuser communication<br></span></span></p>\n<figure class=\"post__image\"><a href=\"https://camelot-os.h2lab.org/media/files/sentry-kernel-design-svcexch.pdf\"  target=\"_blank\" rel=\"noopener noreferrer\" download><img loading=\"lazy\" class=\"post__image\" src=\"https://camelot-os.h2lab.org/media/posts/7/Screenshot-from-2026-01-17-16-09-32.png\" alt=\"\" width=\"1041\" height=\"583\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://camelot-os.h2lab.org/media/posts/7/responsive/Screenshot-from-2026-01-17-16-09-32-xs.webp 640w ,https://camelot-os.h2lab.org/media/posts/7/responsive/Screenshot-from-2026-01-17-16-09-32-sm.webp 768w ,https://camelot-os.h2lab.org/media/posts/7/responsive/Screenshot-from-2026-01-17-16-09-32-md.webp 1024w ,https://camelot-os.h2lab.org/media/posts/7/responsive/Screenshot-from-2026-01-17-16-09-32-lg.webp 1366w ,https://camelot-os.h2lab.org/media/posts/7/responsive/Screenshot-from-2026-01-17-16-09-32-xl.webp 1600w ,https://camelot-os.h2lab.org/media/posts/7/responsive/Screenshot-from-2026-01-17-16-09-32-2xl.webp 1920w\"></figure></a></p>\n<p>¬†</p>",
            "author": {
                "name": "H2Lab Development Team"
            },
            "tags": [
            ],
            "date_published": "2026-01-17T12:17:06+01:00",
            "date_modified": "2026-01-17T16:10:50+01:00"
        },
        {
            "id": "https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-3/",
            "url": "https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-3/",
            "title": "Formal proof in embedded systems part 3",
            "summary": "Alongside noRTE coverage, the Sentry kernel aims to hold functional proofs for its critical functions. One of them is the memory management part, that is responsible to ensure the W^X property of all memory regions mapped, for both kernel an user tasks. This work has&hellip;",
            "content_html": "<p><span class=\"break-words\n          tvm-parent-container\"><span dir=\"ltr\"><br>Alongside noRTE coverage, the Sentry kernel aims to hold functional proofs for its critical functions. One of them is the memory management part, that is responsible to ensure the W^X property of all memory regions mapped, for both kernel an user tasks.<br><br>This work has been done again with Frama-C framework, with the WP plugin, in order to demonstrate that whatever the inputs delivered to the memory region configuration function, the algorithm never permits a write-execute mapping of any regions.<br>This work has been done at the memory protection unit manipulation sub-program, for which the coverage has already been made with EVA, as described in the previous post.<br><br>Here, we explain how the W^X property is demonstrated, based on the effective hardware IP (PMSAv7 &amp; PMSAv8) driver implementation, knowning the CMSIS MPU registers definition given by ARM.</span></span></p>\n<figure class=\"post__image\"><a href=\"https://camelot-os.h2lab.org/media/files/sentry-frama-c-w-x.pdf\"  download><img loading=\"lazy\" class=\"post__image\" src=\"https://camelot-os.h2lab.org/media/posts/6/Screenshot-from-2026-01-17-16-11-48.png\" alt=\"\" width=\"862\" height=\"482\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://camelot-os.h2lab.org/media/posts/6/responsive/Screenshot-from-2026-01-17-16-11-48-xs.webp 640w ,https://camelot-os.h2lab.org/media/posts/6/responsive/Screenshot-from-2026-01-17-16-11-48-sm.webp 768w ,https://camelot-os.h2lab.org/media/posts/6/responsive/Screenshot-from-2026-01-17-16-11-48-md.webp 1024w ,https://camelot-os.h2lab.org/media/posts/6/responsive/Screenshot-from-2026-01-17-16-11-48-lg.webp 1366w ,https://camelot-os.h2lab.org/media/posts/6/responsive/Screenshot-from-2026-01-17-16-11-48-xl.webp 1600w ,https://camelot-os.h2lab.org/media/posts/6/responsive/Screenshot-from-2026-01-17-16-11-48-2xl.webp 1920w\"></figure></a></p>",
            "author": {
                "name": "H2Lab Development Team"
            },
            "tags": [
            ],
            "date_published": "2026-01-17T12:16:02+01:00",
            "date_modified": "2026-01-17T16:12:41+01:00"
        },
        {
            "id": "https://camelot-os.h2lab.org/sentry-kernel-key-concepts-part-1-basics/",
            "url": "https://camelot-os.h2lab.org/sentry-kernel-key-concepts-part-1-basics/",
            "title": "Sentry Kernel key concepts part 1: Basics",
            "summary": "When it comes to embedded systems, security and reliability aren‚Äôt just features‚Äîthey‚Äôre requirements. That‚Äôs why we built the Sentry Kernel, a preemptive micro-kernel designed for micro-controllers, with security baked in from the ground up. üîë Key Highlights: Minimal attack surface: Only critical devices (like DMA)&hellip;",
            "content_html": "<p><span class=\"break-words\n          tvm-parent-container\"><span dir=\"ltr\">When it comes to embedded systems, security and reliability aren‚Äôt just features‚Äîthey‚Äôre requirements. That‚Äôs why we built the Sentry Kernel, a preemptive micro-kernel designed for micro-controllers, with security baked in from the ground up.<br><br>üîë Key Highlights:</span></span></p>\n<p><span class=\"break-words\n          tvm-parent-container\"><span dir=\"ltr\"><br>Minimal attack surface: Only critical devices (like DMA) under kernel control<br>Strong isolation: Partitioned user-space tasks and domains<br>Event-driven execution: Predictable, controlled flow with IRQ, IPC, signals, and DMA events<br>Handle-based access: No direct pointers‚Äîsecure, opaque handles for all OS resources<br>Portable architecture: Clean separation into ASP, BSP, and Generic Kernel layers for easy portability and maintenance<br>Resilience: Built to withstand logical attacks and fault injection<br><br>üìö Learn more &amp; explore the code:<br>GitHub ‚Üí <a href=\"https://lnkd.in/e4gDtpdx\"  target=\"_self\"  data-test-app-aware-link=\"\" tabindex=\"0\" class=\"aKgoauviAZxJAadjRGfyvORexGDtmbTuwaEng  extlink extlink-icon-1\"  >https://lnkd.in/e4gDtpdx</a><br>Docs ‚Üí <a href=\"https://lnkd.in/e4A_7Sky\"  target=\"_self\"  data-test-app-aware-link=\"\" tabindex=\"0\" class=\"aKgoauviAZxJAadjRGfyvORexGDtmbTuwaEng  extlink extlink-icon-1\"  >https://lnkd.in/e4A_7Sky</a><br></span></span></p>",
            "author": {
                "name": "H2Lab Development Team"
            },
            "tags": [
            ],
            "date_published": "2026-01-17T12:15:34+01:00",
            "date_modified": "2026-01-17T12:15:34+01:00"
        },
        {
            "id": "https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-2/",
            "url": "https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-2/",
            "title": "Formal proof in embedded systems part 2",
            "summary": "To complete the Sentry-kernel entrypoint noRTE coverage (https://lnkd.in/evZeGVmG), a lot of work has been made in order to cover other kernel interfaces, starting with handlers and the bigger of all: the syscall gate. This work has been done again with Frama-C framework, by crafting an&hellip;",
            "content_html": "<p><span class=\"break-words\n          tvm-parent-container\"><span dir=\"ltr\"><br>To complete the Sentry-kernel entrypoint noRTE coverage (<a href=\"https://lnkd.in/evZeGVmG\"  target=\"_self\"  data-test-app-aware-link=\"\" tabindex=\"0\" class=\"aKgoauviAZxJAadjRGfyvORexGDtmbTuwaEng  extlink extlink-icon-1\"  >https://lnkd.in/evZeGVmG</a>), a lot of work has been made in order to cover other kernel interfaces, starting with handlers and the bigger of all: the syscall gate.<br><br>This work has been done again with Frama-C framework, by crafting an emulated entrypoint from which the kernel consecutively :<br>- call the bootstrap entrypoint equivalent<br>- generate external inputs (such as user task frames) randomized content<br>- call the handler top entrypoint to cover all the potential call graph.<br><br>More critical handlers (syscall gate, ticker with scheduler) has been covered. Fault and userspace IRQ top-halves still need to be covered.</span></span></p>",
            "author": {
                "name": "H2Lab Development Team"
            },
            "tags": [
            ],
            "date_published": "2026-01-17T12:15:10+01:00",
            "date_modified": "2026-01-17T12:15:10+01:00"
        },
        {
            "id": "https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-1/",
            "url": "https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-1/",
            "title": "Formal proof in embedded systems part 1",
            "summary": "During the last months, a lot of work has been done in the Sentry kernel in order to validate the absence of run time error, including all undefined behaviors, but also usual RTEs such as invalid memory access, out-of-bounds and integer algorithmic errors not being&hellip;",
            "content_html": "<p><span class=\"break-words\n          tvm-parent-container\"><span dir=\"ltr\">During the last months, a lot of work has been done in the Sentry kernel in order to validate the absence of run time error, including all undefined behaviors, but also usual RTEs such as invalid memory access, out-of-bounds and integer algorithmic errors not being UB (overflow, downcast, etc.).<br><br>This work has been done with Frama-C framework, and works well even when targeting embedded kernel (typically targeting armv7-m and armv8-m).<br><br>We also cover low level parts such as drivers and hardware registers manipulations.<br><br></span></span></p>\n<figure class=\"post__image\"><a href=\"https://camelot-os.h2lab.org/media/files/sentry-framac-entrypoint.pdf\" ><img loading=\"lazy\" class=\"post__image\" src=\"https://camelot-os.h2lab.org/media/posts/3/Screenshot-from-2026-01-17-16-13-18.png\" alt=\"\" width=\"863\" height=\"484\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://camelot-os.h2lab.org/media/posts/3/responsive/Screenshot-from-2026-01-17-16-13-18-xs.webp 640w ,https://camelot-os.h2lab.org/media/posts/3/responsive/Screenshot-from-2026-01-17-16-13-18-sm.webp 768w ,https://camelot-os.h2lab.org/media/posts/3/responsive/Screenshot-from-2026-01-17-16-13-18-md.webp 1024w ,https://camelot-os.h2lab.org/media/posts/3/responsive/Screenshot-from-2026-01-17-16-13-18-lg.webp 1366w ,https://camelot-os.h2lab.org/media/posts/3/responsive/Screenshot-from-2026-01-17-16-13-18-xl.webp 1600w ,https://camelot-os.h2lab.org/media/posts/3/responsive/Screenshot-from-2026-01-17-16-13-18-2xl.webp 1920w\"></figure></a></p>",
            "author": {
                "name": "H2Lab Development Team"
            },
            "tags": [
            ],
            "date_published": "2026-01-17T12:14:37+01:00",
            "date_modified": "2026-01-17T16:14:11+01:00"
        },
        {
            "id": "https://camelot-os.h2lab.org/introducing-camelot-os/",
            "url": "https://camelot-os.h2lab.org/introducing-camelot-os/",
            "title": "Introducing Camelot-OS",
            "summary": "A New Open-Source Operating System for Secure IoT The Internet of Things (IoT) continues to transform everyday life ‚Äî from connected wearables to industrial controllers ‚Äî but this rapid growth also brings new security challenges. Embedded devices often run lightweight operating systems that prioritize performance&hellip;",
            "content_html": "<h2 id=\"a-new-open-source-operating-system-for-secure-iot\">A New Open-Source Operating System for Secure IoT</h2>\n<p>The Internet of Things (IoT) continues to transform everyday life ‚Äî from connected wearables to industrial controllers ‚Äî but this rapid growth also brings new security challenges. Embedded devices often run lightweight operating systems that prioritize performance and low power usage, sometimes at the expense of safety and robustness. Recognizing this gap, the Camelot-OS project has emerged as an open-source initiative aimed at building a modern, trustworthy foundation for secure IoT systems.</p><h2 id=\"what-is-camelot-os\">What Is Camelot-OS?</h2>\n<p>Hosted under the camelot-os namespace on GitHub, Camelot-OS encompasses a family of repositories focused on an open-source, security-oriented operating system ecosystem for embedded devices. The most prominent component visible today is the Sentry kernel, a high-security microkernel designed specifically for embedded systems that include microcontrollers and security hardware like Secure Elements. This microkernel architecture is crafted to provide strong isolation between components ‚Äî a cornerstone for secure firmware and trusted execution environments in constrained devices.</p><p>Alongside the kernel itself, the Camelot-OS organization includes supporting tooling such as SDKs, device-tree utilities, and sample applications ‚Äî all building blocks toward a fully integrated, open IoT OS.</p><h2 id=\"why-it-matters-security-and-industrial-grade-quality\">Why It Matters: Security and Industrial-Grade Quality</h2>\n<p>The genesis of the Camelot-OS vision aligns with discussions from SSTIC 2024, one of the premier security conferences in Europe. In the talk ‚ÄúOnce upon a time in IoT: an industry-grade OS perspective for IoT security‚Äù, experts outlined how current Open-Source solutions fall short for high-security, high-robustness use cases in industrial IoT. After reviewing the state of the art and finding no sufficiently secure open solution for modern microcontroller platforms, they described efforts to build a versatile, security-oriented OS ‚Äî laying conceptual groundwork that resonates with Camelot-OS‚Äôs goals of runtime isolation, robustness, and industrial tooling support.</p><p>This context highlights why an open project like Camelot-OS is especially relevant today: it bridges the gap between academic/proprietary secure OS research and practical, community-driven tools that developers and integrators can adopt and evolve collectively.</p><h2 id=\"key-features-and-philosophy\">Key Features and Philosophy</h2>\n<p>While the project is actively evolving, several themes are clear from its repositories and documentation:</p><p><em>Microkernel Architecture</em>: By minimizing the trusted computing base and isolating components, Camelot-OS aims for a secure foundation appropriate for sensitive embedded tasks.</p><p><em>Secure Integration</em>: Designed with hardware security modules in mind (e.g., secure elements), enabling strong cryptographic backing for operations.</p><p><em>Open-Source Collaboration</em>: The project welcomes contributions through its modular repos, including SDKs and examples, lowering the barrier for developers to experiment and contribute.</p><p><em>Toolchain and Industrial Readiness</em>: Influenced by modern build systems and workflows similar to industry standards, enabling reproducible builds and traceable software supply chains.</p><p><em>standalone offline production</em>: With the industrial constraints in mind, such as confidentiality requirements and disconnected or air-gapped production environment, Camelot-OS is made in order to allows fully autonomous and offline project configuration and delivery, including in the same time Open-Source components and industrial value added for project-relative specific functional parts</p><h2 id=\"who-should-care\">Who Should Care?</h2>\n<p>Camelot-OS will be of interest to:</p><p>IoT developers building embedded products that need strong isolation and security features.</p><p>Security researchers exploring microkernel-based operating systems and secure embedded design.</p><p>Open-source contributors drawn to operating system internals, safety-critical code, and platform-agnostic tooling.</p><p>Product engineers evaluating alternatives to traditional RTOS platforms that may lack formal isolation or robust security tooling.</p><p>As Camelot-OS evolves, it promises to become a vital option in the landscape of secure, open IoT operating systems ‚Äî combining academic rigor, community collaboration, and real-world industrial insight. Stay tuned for deeper dives into its architecture, tooling, and how to build your first application on top of it.</p><p>If you want, I can also help write a follow-up post about Camelot-OS‚Äôs architecture, how to get started with the SDK, or a comparison with other IoT OS choices.</p>",
            "author": {
                "name": "H2Lab Development Team"
            },
            "tags": [
            ],
            "date_published": "2026-01-17T11:29:51+01:00",
            "date_modified": "2026-01-17T11:29:51+01:00"
        }
    ]
}
