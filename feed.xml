<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Camelot Operating System</title>
    <link href="https://camelot-os.github.io/feed.xml" rel="self" />
    <link href="https://camelot-os.github.io" />
    <updated>2026-01-17T14:29:56+01:00</updated>
    <author>
        <name>H2Lab Development Team</name>
    </author>
    <id>https://camelot-os.github.io</id>

    <entry>
        <title>Exploring Pointer-Free Data Exchange in Sentry</title>
        <author>
            <name>H2Lab Development Team</name>
        </author>
        <link href="https://camelot-os.github.io/exploring-pointer-free-data-exchange-in-sentry.html"/>
        <id>https://camelot-os.github.io/exploring-pointer-free-data-exchange-in-sentry.html</id>

        <updated>2026-01-17T12:17:06+01:00</updated>
            <summary type="html">
                <![CDATA[
                    When diving into Sentry-micro-kernel concepts, one design choice really stood out: no pointer passing between user space and kernel space. Instead of relying on pointers, Sentry uses a dedicated buffer called svc_exchange to transfer data between applications and the kernel. This simple but powerful approach:&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><span class="break-words
          tvm-parent-container"><span dir="ltr">When diving into Sentry-micro-kernel concepts, one design choice really stood out: no pointer passing between user space and kernel space.<br>Instead of relying on pointers, Sentry uses a dedicated buffer called svc_exchange to transfer data between applications and the kernel.<br>This simple but powerful approach:<br>üîí Strengthens security (no unsafe pointer dereferencing)<br>üìê Simplifies formal verification<br>‚ö° Keeps the kernel lightweight and predictable<br><br>Here is how this pointer-free exchange model works, its strengths, limitations, and what it means for developers.<br>üëâ Key takeaway: sometimes removing a feature (pointers) is the best way to reduce complexity and improve system robustness. This is a key design being a balance between security, simplicity, and performance in kernel‚Äìuser communication<br></span></span></p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Formal proof in embedded systems part 3</title>
        <author>
            <name>H2Lab Development Team</name>
        </author>
        <link href="https://camelot-os.github.io/formal-proof-in-embedded-systems-part-3.html"/>
        <id>https://camelot-os.github.io/formal-proof-in-embedded-systems-part-3.html</id>

        <updated>2026-01-17T12:16:02+01:00</updated>
            <summary type="html">
                <![CDATA[
                    Alongside noRTE coverage, the Sentry kernel aims to hold functional proofs for its critical functions. One of them is the memory management part, that is responsible to ensure the W^X property of all memory regions mapped, for both kernel an user tasks. This work has&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><span class="break-words
          tvm-parent-container"><span dir="ltr"><br>Alongside noRTE coverage, the Sentry kernel aims to hold functional proofs for its critical functions. One of them is the memory management part, that is responsible to ensure the W^X property of all memory regions mapped, for both kernel an user tasks.<br><br>This work has been done again with Frama-C framework, with the WP plugin, in order to demonstrate that whatever the inputs delivered to the memory region configuration function, the algorithm never permits a write-execute mapping of any regions.<br>This work has been done at the memory protection unit manipulation sub-program, for which the coverage has already been made with EVA, as described in the previous post.<br><br>Here, we explain how the W^X property is demonstrated, based on the effective hardware IP (PMSAv7 &amp; PMSAv8) driver implementation, knowning the CMSIS MPU registers definition given by ARM.</span></span></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Sentry Kernel key concepts part 1: Basics</title>
        <author>
            <name>H2Lab Development Team</name>
        </author>
        <link href="https://camelot-os.github.io/sentry-kernel-key-concepts-part-1-basics.html"/>
        <id>https://camelot-os.github.io/sentry-kernel-key-concepts-part-1-basics.html</id>

        <updated>2026-01-17T12:15:34+01:00</updated>
            <summary type="html">
                <![CDATA[
                    When it comes to embedded systems, security and reliability aren‚Äôt just features‚Äîthey‚Äôre requirements. That‚Äôs why we built the Sentry Kernel, a preemptive micro-kernel designed for micro-controllers, with security baked in from the ground up. üîë Key Highlights: Minimal attack surface: Only critical devices (like DMA)&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><span class="break-words
          tvm-parent-container"><span dir="ltr">When it comes to embedded systems, security and reliability aren‚Äôt just features‚Äîthey‚Äôre requirements. That‚Äôs why we built the Sentry Kernel, a preemptive micro-kernel designed for micro-controllers, with security baked in from the ground up.<br><br>üîë Key Highlights:</span></span></p>
<p><span class="break-words
          tvm-parent-container"><span dir="ltr"><br>Minimal attack surface: Only critical devices (like DMA) under kernel control<br>Strong isolation: Partitioned user-space tasks and domains<br>Event-driven execution: Predictable, controlled flow with IRQ, IPC, signals, and DMA events<br>Handle-based access: No direct pointers‚Äîsecure, opaque handles for all OS resources<br>Portable architecture: Clean separation into ASP, BSP, and Generic Kernel layers for easy portability and maintenance<br>Resilience: Built to withstand logical attacks and fault injection<br><br>üìö Learn more &amp; explore the code:<br>GitHub ‚Üí <a href="https://lnkd.in/e4gDtpdx"  target="_self"  data-test-app-aware-link="" tabindex="0" class="aKgoauviAZxJAadjRGfyvORexGDtmbTuwaEng  extlink extlink-icon-1"  >https://lnkd.in/e4gDtpdx</a><br>Docs ‚Üí <a href="https://lnkd.in/e4A_7Sky"  target="_self"  data-test-app-aware-link="" tabindex="0" class="aKgoauviAZxJAadjRGfyvORexGDtmbTuwaEng  extlink extlink-icon-1"  >https://lnkd.in/e4A_7Sky</a><br></span></span></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Formal proof in embedded systems part 2</title>
        <author>
            <name>H2Lab Development Team</name>
        </author>
        <link href="https://camelot-os.github.io/formal-proof-in-embedded-systems-part-2.html"/>
        <id>https://camelot-os.github.io/formal-proof-in-embedded-systems-part-2.html</id>

        <updated>2026-01-17T12:15:10+01:00</updated>
            <summary type="html">
                <![CDATA[
                    To complete the Sentry-kernel entrypoint noRTE coverage (https://lnkd.in/evZeGVmG), a lot of work has been made in order to cover other kernel interfaces, starting with handlers and the bigger of all: the syscall gate. This work has been done again with Frama-C framework, by crafting an&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><span class="break-words
          tvm-parent-container"><span dir="ltr"><br>To complete the Sentry-kernel entrypoint noRTE coverage (<a href="https://lnkd.in/evZeGVmG"  target="_self"  data-test-app-aware-link="" tabindex="0" class="aKgoauviAZxJAadjRGfyvORexGDtmbTuwaEng  extlink extlink-icon-1"  >https://lnkd.in/evZeGVmG</a>), a lot of work has been made in order to cover other kernel interfaces, starting with handlers and the bigger of all: the syscall gate.<br><br>This work has been done again with Frama-C framework, by crafting an emulated entrypoint from which the kernel consecutively :<br>- call the bootstrap entrypoint equivalent<br>- generate external inputs (such as user task frames) randomized content<br>- call the handler top entrypoint to cover all the potential call graph.<br><br>More critical handlers (syscall gate, ticker with scheduler) has been covered. Fault and userspace IRQ top-halves still need to be covered.</span></span></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Formal proof in embedded systems part 1</title>
        <author>
            <name>H2Lab Development Team</name>
        </author>
        <link href="https://camelot-os.github.io/formal-proof-in-embedded-systems-part-1.html"/>
        <id>https://camelot-os.github.io/formal-proof-in-embedded-systems-part-1.html</id>

        <updated>2026-01-17T12:14:37+01:00</updated>
            <summary type="html">
                <![CDATA[
                    During the last months, a lot of work has been done in the Sentry kernel in order to validate the absence of run time error, including all undefined behaviors, but also usual RTEs such as invalid memory access, out-of-bounds and integer algorithmic errors not being&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><span class="break-words
          tvm-parent-container"><span dir="ltr">During the last months, a lot of work has been done in the Sentry kernel in order to validate the absence of run time error, including all undefined behaviors, but also usual RTEs such as invalid memory access, out-of-bounds and integer algorithmic errors not being UB (overflow, downcast, etc.).<br><br>This work has been done with Frama-C framework, and works well even when targeting embedded kernel (typically targeting armv7-m and armv8-m).<br><br>We also cover low level parts such as drivers and hardware registers manipulations.<br><br>See <a href="https://lnkd.in/eGaGnTHt"  target="_self"  data-test-app-aware-link="" tabindex="0" class="aKgoauviAZxJAadjRGfyvORexGDtmbTuwaEng  extlink extlink-icon-1"  >https://lnkd.in/eGaGnTHt</a> for more information</span></span></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Introducing Camelot-OS</title>
        <author>
            <name>H2Lab Development Team</name>
        </author>
        <link href="https://camelot-os.github.io/introducing-camelot-os.html"/>
        <id>https://camelot-os.github.io/introducing-camelot-os.html</id>

        <updated>2026-01-17T11:29:51+01:00</updated>
            <summary type="html">
                <![CDATA[
                    A New Open-Source Operating System for Secure IoT The Internet of Things (IoT) continues to transform everyday life ‚Äî from connected wearables to industrial controllers ‚Äî but this rapid growth also brings new security challenges. Embedded devices often run lightweight operating systems that prioritize performance&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="a-new-open-source-operating-system-for-secure-iot">A New Open-Source Operating System for Secure IoT</h2>
<p>The Internet of Things (IoT) continues to transform everyday life ‚Äî from connected wearables to industrial controllers ‚Äî but this rapid growth also brings new security challenges. Embedded devices often run lightweight operating systems that prioritize performance and low power usage, sometimes at the expense of safety and robustness. Recognizing this gap, the Camelot-OS project has emerged as an open-source initiative aimed at building a modern, trustworthy foundation for secure IoT systems.</p><h2 id="what-is-camelot-os">What Is Camelot-OS?</h2>
<p>Hosted under the camelot-os namespace on GitHub, Camelot-OS encompasses a family of repositories focused on an open-source, security-oriented operating system ecosystem for embedded devices. The most prominent component visible today is the Sentry kernel, a high-security microkernel designed specifically for embedded systems that include microcontrollers and security hardware like Secure Elements. This microkernel architecture is crafted to provide strong isolation between components ‚Äî a cornerstone for secure firmware and trusted execution environments in constrained devices.</p><p>Alongside the kernel itself, the Camelot-OS organization includes supporting tooling such as SDKs, device-tree utilities, and sample applications ‚Äî all building blocks toward a fully integrated, open IoT OS.</p><h2 id="why-it-matters-security-and-industrial-grade-quality">Why It Matters: Security and Industrial-Grade Quality</h2>
<p>The genesis of the Camelot-OS vision aligns with discussions from SSTIC 2024, one of the premier security conferences in Europe. In the talk ‚ÄúOnce upon a time in IoT: an industry-grade OS perspective for IoT security‚Äù, experts outlined how current Open-Source solutions fall short for high-security, high-robustness use cases in industrial IoT. After reviewing the state of the art and finding no sufficiently secure open solution for modern microcontroller platforms, they described efforts to build a versatile, security-oriented OS ‚Äî laying conceptual groundwork that resonates with Camelot-OS‚Äôs goals of runtime isolation, robustness, and industrial tooling support.</p><p>This context highlights why an open project like Camelot-OS is especially relevant today: it bridges the gap between academic/proprietary secure OS research and practical, community-driven tools that developers and integrators can adopt and evolve collectively.</p><h2 id="key-features-and-philosophy">Key Features and Philosophy</h2>
<p>While the project is actively evolving, several themes are clear from its repositories and documentation:</p><p><em>Microkernel Architecture</em>: By minimizing the trusted computing base and isolating components, Camelot-OS aims for a secure foundation appropriate for sensitive embedded tasks.</p><p><em>Secure Integration</em>: Designed with hardware security modules in mind (e.g., secure elements), enabling strong cryptographic backing for operations.</p><p><em>Open-Source Collaboration</em>: The project welcomes contributions through its modular repos, including SDKs and examples, lowering the barrier for developers to experiment and contribute.</p><p><em>Toolchain and Industrial Readiness</em>: Influenced by modern build systems and workflows similar to industry standards, enabling reproducible builds and traceable software supply chains.</p><p><em>standalone offline production</em>: With the industrial constraints in mind, such as confidentiality requirements and disconnected or air-gapped production environment, Camelot-OS is made in order to allows fully autonomous and offline project configuration and delivery, including in the same time Open-Source components and industrial value added for project-relative specific functional parts</p><h2 id="who-should-care">Who Should Care?</h2>
<p>Camelot-OS will be of interest to:</p><p>IoT developers building embedded products that need strong isolation and security features.</p><p>Security researchers exploring microkernel-based operating systems and secure embedded design.</p><p>Open-source contributors drawn to operating system internals, safety-critical code, and platform-agnostic tooling.</p><p>Product engineers evaluating alternatives to traditional RTOS platforms that may lack formal isolation or robust security tooling.</p><p>As Camelot-OS evolves, it promises to become a vital option in the landscape of secure, open IoT operating systems ‚Äî combining academic rigor, community collaboration, and real-world industrial insight. Stay tuned for deeper dives into its architecture, tooling, and how to build your first application on top of it.</p><p>If you want, I can also help write a follow-up post about Camelot-OS‚Äôs architecture, how to get started with the SDK, or a comparison with other IoT OS choices.</p>
            ]]>
        </content>
    </entry>
</feed>
