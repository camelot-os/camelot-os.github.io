<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Why Formal Verification Matters in the Sentry Microkernel - Camelot Operating System</title><meta name="description" content="Micro-kernels such as Sentry aim to provide strong isolation, minimal trusted computing bases, and high assurance for embedded and security-critical systems. However, achieving these goals in practice is difficult: subtle bugs in low-level code, memory protection, or context switching can completely undermine the intended security&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://camelot-os.h2lab.org/media/plugins/syntaxHighlighter/prism-beige.css"><link rel="stylesheet" href="https://camelot-os.h2lab.org/media/plugins/syntaxHighlighter/prism-inline-color.css"><link rel="canonical" href="https://camelot-os.h2lab.org/why-formal-verification-matters-in-the-sentry-microkernel/"><link rel="alternate" type="application/atom+xml" href="https://camelot-os.h2lab.org/feed.xml" title="Camelot Operating System - RSS"><link rel="alternate" type="application/json" href="https://camelot-os.h2lab.org/feed.json" title="Camelot Operating System - JSON"><meta property="og:title" content="Why Formal Verification Matters in the Sentry Microkernel"><meta property="og:image" content="https://camelot-os.h2lab.org/media/website/camelot-OS.png"><meta property="og:image:width" content="323"><meta property="og:image:height" content="342"><meta property="og:site_name" content="Camelot Operating System"><meta property="og:description" content="Micro-kernels such as Sentry aim to provide strong isolation, minimal trusted computing bases, and high assurance for embedded and security-critical systems. However, achieving these goals in practice is difficult: subtle bugs in low-level code, memory protection, or context switching can completely undermine the intended security&hellip;"><meta property="og:url" content="https://camelot-os.h2lab.org/why-formal-verification-matters-in-the-sentry-microkernel/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://camelot-os.h2lab.org/media/website/h2lab.png" type="image/png"><link rel="stylesheet" href="https://camelot-os.h2lab.org/assets/css/style.css?v=1d12dfc293a797122c81fcead8a9b6ac"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://camelot-os.h2lab.org/why-formal-verification-matters-in-the-sentry-microkernel/"},"headline":"Why Formal Verification Matters in the Sentry Microkernel","datePublished":"2026-01-18T08:58+01:00","dateModified":"2026-01-30T18:45+01:00","image":{"@type":"ImageObject","url":"https://camelot-os.h2lab.org/media/website/camelot-OS.png","height":342,"width":323},"description":"Micro-kernels such as Sentry aim to provide strong isolation, minimal trusted computing bases, and high assurance for embedded and security-critical systems. However, achieving these goals in practice is difficult: subtle bugs in low-level code, memory protection, or context switching can completely undermine the intended security&hellip;","author":{"@type":"Person","name":"H2Lab Development Team","url":"https://camelot-os.h2lab.org/authors/h2lab-development-team/"},"publisher":{"@type":"Organization","name":"H2Lab Development Team","logo":{"@type":"ImageObject","url":"https://camelot-os.h2lab.org/media/website/camelot-OS.png","height":342,"width":323}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><style>.extlink::after {
				background-color: currentColor;
				content: "";
				display: inline-block;
				height: 16px;
				margin-left: 5px;
				position: relative;
				top: 0px;
				width: 16px;
			}
		
					.extlink.extlink-icon-1::after {
						mask-image: url("data:image/svg+xml;utf8,<svg viewBox='0 0 24 24' fill='none' stroke='%23000000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' xmlns='http://www.w3.org/2000/svg'><path d='M15 3h6v6'/><path d='M10 14 21 3'/><path d='M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6'/></svg>");
						mask-repeat: no-repeat;
						mask-size: contain;
					}</style><style>.ti{fill:none;stroke-linecap:round;stroke-linejoin:round;vertical-align:middle}</style><style>:root {--toc-max-height: auto;}html {scroll-padding-top: 2rem;}.post__toc h2{align-items: center;border: none;cursor: pointer;display: inline-flex;gap: .5em;margin: 0;padding: 0;user-select: none;}.post__toc > ol {margin-left: 0;max-height: 0;overflow: auto;opacity: 0;transition: opacity 0.3s ease-out, max-height 0.5s ease-out;}.post__toc > ol[aria-hidden="false"] {max-height: var(--toc-max-height);opacity: 1;transition: opacity 0.3s ease-in, max-height 0.5s ease-in;}.post__toc ol {counter-reset: item;list-style: none;}.post__toc li {padding-left: 0;padding-bottom: 0;}.post__toc ol ol {margin-left: 1.5rem;margin-top: 0;}.post__toc ol ol li::before {margin-left: 0;}.post__toc a {align-items: stretch;color: var(--toc-link-color, var(--link-color));display: inline-flex;flex-wrap: nowrap;}.post__toc a:hover, .post__toc a:active, .post__toc a:focus {color: var(--toc-link-color-hover, var(--link-color-hover));}.post__toc a::before {content: counters(item, ".", none) ". ";counter-increment: item;color: var(--toc-number-color, var(--text-color));display: inline-block;flex-grow: 0;flex-shrink: 0;margin-right: 0.2em;}.post__toc-toggle {background: none;border: none;border-radius: 0;box-shadow: none;color: var(--toc-toggle-link-color, var(--color));cursor: pointer;display: inline;font-weight: normal;overflow: visible;padding: 0;text-align: left;text-decoration: none;text-transform: none;vertical-align: baseline;will-change: unset;}.post__toc-toggle:hover, .post__toc-toggle:active, .post__toc-toggle:focus {background: inherit;border: inherit;box-shadow: inherit;color: var(--toc-toggle-link-color-hover, var(--color, inherit));text-decoration: none;transform: inherit;}.post__toc-toggle::before{content: "[";color: var(--toc-toggle-color, var(--text-color));}.post__toc-toggle::after {content: "]";color: var(--toc-toggle-color, var(--text-color));}</style><noscript><style>.post__toc > ol {max-height: var(--toc-max-height);opacity: 1;transition: none;}.post__toc h2{cursor: default;}</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://camelot-os.h2lab.org/"><img src="https://camelot-os.h2lab.org/media/website/camelot-OS.png" alt="Camelot Operating System" width="323" height="342"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li class="has-submenu"><span class="is-separator" aria-haspopup="true">Pages</span><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://camelot-os.h2lab.org/camelot-os-because-secure-systems-deserve-a-secure-foundation/" target="_self">Introduction</a></li><li><a href="https://camelot-os.h2lab.org/sentry-micro-kernel/" target="_self">Sentry micro-kernel</a></li><li><a href="https://camelot-os.h2lab.org/camelot-os-sdk/" target="_self">Camelot SDK</a></li></ul></li><li><a href="https://camelot-os.h2lab.org/" target="_self">Blog Posts</a></li><li class="has-submenu"><span class="is-separator" aria-haspopup="true">Documentation</span><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://sentry-kernel.readthedocs.io/en/latest/" target="_blank">Sentry kernel</a></li><li class="has-submenu"><span class="is-separator" aria-haspopup="true">Howtos</span><ul class="navbar__submenu level-3" aria-hidden="true"><li><a href="https://camelot-os.h2lab.org/runing-kernel-autotests/" target="_self">Autotesting Sentry kernel</a></li><li><a href="https://camelot-os.h2lab.org/how-to-create-a-camelot-os-project/" target="_self">Run a Camelot-OS project</a></li><li><a href="https://camelot-os.h2lab.org/bootstrap-a-rust-application/" target="_self">Bootsrap your Rust application</a></li></ul></li></ul></li><li class="has-submenu"><span class="is-separator" aria-haspopup="true">Repositories</span><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://github.com/camelot-os/sentry-kernel" target="_blank">Sentry Kernel</a></li><li><a href="https://github.com/camelot-os/shield" target="_self">Shield runtime</a></li><li><a href="https://github.com/camelot-os/shield" target="_self">Barbican project manager</a></li></ul></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="wrapper search__overlay-inner"></div></div><button class="search__btn btn--icon js-search-btn" aria-label="Search"><svg height="18" width="18" role="presentation" focusable="false"><use xlink:href="https://camelot-os.h2lab.org/assets/svg/svg-map.svg#search"/></svg></button></div></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Why Formal Verification Matters in the Sentry Microkernel</h1><div class="feed__meta content__meta"><a href="https://camelot-os.h2lab.org/authors/h2lab-development-team/" class="feed__author">H2Lab Development Team</a> <time datetime="2026-01-18T08:58" class="feed__date">January 18, 2026 </time><span class="reading-time" aria-label="8 min read">8 min read</span></div></div></header></div><div class="entry-wrapper content__entry"><p data-start="335" data-end="677">Micro-kernels such as <strong data-start="356" data-end="366">Sentry</strong> aim to provide strong isolation, minimal trusted computing bases, and high assurance for embedded and security-critical systems. However, achieving these goals in practice is difficult: subtle bugs in low-level code, memory protection, or context switching can completely undermine the intended security model.</p><p data-start="679" data-end="984">This is where <strong data-start="693" data-end="716">formal verification</strong> becomes a decisive advantage. In Sentry, formal methods are not an afterthought or an academic exercise‚Äîthey directly shape the kernel‚Äôs architecture and implementation, particularly in security-critical subsystems such as <strong data-start="940" data-end="983">MPU (Memory Protection Unit) management</strong>.</p><h2 data-start="991" data-end="1039">What Does Formal Verification Mean in Sentry?</h2><p data-start="1041" data-end="1411">Formal verification consists in specifying the intended behavior of the kernel precisely and <strong data-start="1134" data-end="1160">mathematically proving</strong> that the implementation satisfies those specifications. In Sentry, this approach is applied using static analysis and formally-grounded tools (like <strong data-start="1309" data-end="1320">Frama-C</strong>), letting us establish strong guarantees about memory safety, isolation, and control flow.</p><p data-start="1413" data-end="1606">Unlike testing, which can only demonstrate the presence of bugs in specific test cases, formal verification can prove the <strong data-start="1535" data-end="1574">absence of entire classes of errors</strong> across all possible executions.</p><h2 data-start="1613" data-end="1643">Security by Construction</h2><p data-start="1645" data-end="1835">The kernel is the most privileged component of any system. A single flaw can compromise all applications running on top of it. Formal verification helps Sentry address this risk at its root:</p><ul data-start="1837" data-end="2124"><li data-start="1837" data-end="1897"><p data-start="1839" data-end="1897">It proves that critical invariants hold in all executions.</p></li><li data-start="1898" data-end="2027"><p data-start="1900" data-end="2027">It eliminates classes of bugs such as invalid memory accesses, inconsistent state transitions, or broken isolation assumptions.</p></li><li data-start="2028" data-end="2124"><p data-start="2030" data-end="2124">It provides <em data-start="2042" data-end="2066">mathematical assurance</em> that the verified properties hold for all possible paths.</p></li></ul><p data-start="2126" data-end="2286">This level of assurance is particularly relevant for embedded and cyber-physical systems, where failures can have safety, financial, or regulatory consequences.</p><h2 data-start="2293" data-end="2334">A Kernel Designed for Verifiability</h2><p data-start="2336" data-end="2392">Formal verification strongly influences Sentry‚Äôs design:</p><ul data-start="2394" data-end="2646"><li data-start="2394" data-end="2461"><p data-start="2396" data-end="2461"><strong data-start="2396" data-end="2424">Highly modular structure</strong>, enabling component-level reasoning.</p></li><li data-start="2462" data-end="2544"><p data-start="2464" data-end="2544"><strong data-start="2464" data-end="2497">Clear and explicit interfaces</strong>, which can be formally specified and verified.</p></li><li data-start="2545" data-end="2646"><p data-start="2547" data-end="2646"><strong data-start="2547" data-end="2589">Minimal and encapsulated assembly code</strong>, reducing the unverified surface and simplifying proofs.</p></li></ul><p data-start="2648" data-end="2822">In Sentry, the kernel is not merely verified after implementation; it is <strong data-start="2721" data-end="2750">designed to be verifiable</strong>, which significantly lowers the cost and complexity of formal analysis.</p><h2 data-start="2829" data-end="2889">MPU Management: A Concrete Case of Formal Verification</h2><p data-start="2891" data-end="3001">One of the most compelling applications of formal verification in Sentry is the <strong data-start="2971" data-end="3000">management of MPU regions</strong>.</p><p data-start="3003" data-end="3271">On ARM Cortex-M microcontrollers, the MPU is the primary hardware mechanism used to enforce memory isolation between tasks. Any mistake in MPU configuration can lead to severe vulnerabilities: unintended memory access, privilege escalation, or cross-task interference.</p><p data-start="3273" data-end="3348">Sentry treats MPU management as a first-class, formally reasoned subsystem.</p><h2 data-start="4649" data-end="4701">Example ACSL Specifications for MPU Invariants</h2><p data-start="4703" data-end="4962">Below are example fragments in the style of <strong data-start="4747" data-end="4791">ACSL (ANSI/ISO C Specification Language)</strong> that express core invariants used in Sentry‚Äôs MPU management logic. These are <em data-start="4870" data-end="4884">illustrative</em>, reflecting how formal annotations in <code data-start="4923" data-end="4938">mpu_pmsa_v8.h</code> specify key guarantees.</p><h3 data-start="4703" data-end="4962">About MPU mapping and W^X</h3><p data-start="708" data-end="798">On ARMv8-M the PMSAv8 MPU region validity predicate (in ACSL) says a region is <em data-start="787" data-end="794">valid</em> if:</p><ul data-start="800" data-end="984"><li data-start="800" data-end="876"><p data-start="802" data-end="876">both base and limit are aligned to the MPU region alignment (<code data-start="863" data-end="873">32 bytes</code>)</p></li><li data-start="877" data-end="900"><p data-start="879" data-end="900">the limit is ‚â• base</p></li><li data-start="901" data-end="984"><p data-start="903" data-end="984">OR if the region is empty (RBAR/RLAR = 0)</p></li></ul><p data-start="986" data-end="1062">That last point makes ‚Äúunmapped‚Äù regions represent no actual memory mapping.</p><p data-start="1064" data-end="1140">The architecture imposes <em data-start="1089" data-end="1108">Write-xor-Execute</em> semantics via these properties:</p><ol data-start="1142" data-end="1665"><li data-start="1142" data-end="1238"><p data-start="1145" data-end="1238"><strong data-start="1145" data-end="1202">Executable permissions are encoded in the RBAR XN bit</strong> ‚Äî <code data-start="1205" data-end="1218">noexec == 1</code> ‚Üí non-executable.</p></li><li data-start="1239" data-end="1306"><p data-start="1242" data-end="1306"><strong data-start="1242" data-end="1303">Access permission (AP) bits define read/write constraints</strong>.</p></li><li data-start="1307" data-end="1665"><p data-start="1310" data-end="1442">The Cortex-M PMSAv8 (as profiled in the kernel header) includes <strong data-start="1374" data-end="1388">assertions</strong> that enforce W^X semantics when forging a resource:</p><ul data-start="1446" data-end="1665"><li data-start="1446" data-end="1546"><p data-start="1448" data-end="1546">if <code data-start="1451" data-end="1464">noexec == 0</code> (i.e., region is executable), then the access permission must be RO (read-only)</p></li><li data-start="1550" data-end="1665"><p data-start="1552" data-end="1665">conversely, if the region is writable (non-RO), then <code data-start="1605" data-end="1613">noexec</code> must be set</p></li></ul></li></ol><h3 data-start="4964" data-end="4998">Region-related predicates</h3><p data-start="5000" data-end="5098">A set of predicates has been written to verify region properties, including PMSAv8 conformity and overlapping check to already mapped regions.</p><div class="contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary">¬†</div><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><pre class="language-c"><code>/*@

  predicate aligned_32(‚Ñ§ addr) =
    (addr &amp; MPU_REGION_ALIGN_MASK) == 0;

    predicate mpu_is_empty_region(ARM_MPU_Region_t r1) =
      r1.RBAR == 0 &amp;&amp; r1.RLAR == 0;

  predicate valid_mpu_region(‚Ñ§ base, ‚Ñ§ limit) =
    ((base == 0 &amp;&amp; limit == 0) ||
    (
        aligned_32(base)
        &amp;&amp; aligned_32(limit)
        &amp;&amp; limit &gt;= base
        &amp;&amp; ((limit - base + 1) % MPU_REGION_ALIGN == 0)
    ));

  predicate valid_mpu_regions{L}(ARM_MPU_Region_t *regions, integer n) =
        \forall integer i;
            0 &lt;= i &lt; n ==&gt;
            valid_mpu_region(regions[i].RBAR &amp; MPU_RBAR_BASE_Msk,
                             regions[i].RLAR &amp; MPU_RLAR_LIMIT_Msk);

  predicate non_empty_region(‚Ñ§ base, ‚Ñ§ limit) =
    (limit - base + 1) &gt;= MPU_REGION_ALIGN;

  // when either region is empty, they are considered disjoint
  predicate disjoint(ARM_MPU_Region_t r1, ARM_MPU_Region_t r2) =
      r1.RBAR == 0 &amp;&amp; r1.RLAR == 0 ||
      r2.RBAR == 0 &amp;&amp; r2.RLAR == 0 ||
      (
        (r1.RBAR &amp; MPU_RBAR_BASE_Msk) &lt;= (r2.RLAR &amp; MPU_RLAR_LIMIT_Msk) ||
        (r2.RBAR &amp; MPU_RBAR_BASE_Msk) &lt;= (r1.RLAR &amp; MPU_RLAR_LIMIT_Msk)
      );

  predicate regions_disjoint{L}(ARM_MPU_Region_t *regions, integer n) =
      \forall integer i, j;
        0 &lt;= i &lt; n &amp;&amp; 0 &lt;= j &lt; n &amp;&amp; i != j ==&gt;
          disjoint(regions[i], regions[j]);
*/
</code></pre></div></div><p data-start="5473" data-end="5500">These predicates then need to be added as pre and postconditions of programs that are responsible for manpulatin task memory regions.<br>This is done using a single primitive in the kernel, that add a new region to a given task region set. This primitive is denoted <span style="font-size: inherit;"><code>mgr_task_add_resource()</code>.</span></p><h3 data-start="5565" data-end="5593">Region validity check</h3><pre class="language-c"><code>kstatus_t status;
task_t *cell;

// [...]
if (unlikely(mpu_region_is_valid(&amp;resource) == SECURE_FALSE)) {
        status = K_ERROR_INVPARAM;
        goto err;
}
/* demonstrate that the effective run time check does match the predicate */
/*@ assert valid_mpu_regions(&amp;resource, 1); */</code></pre><h3 data-start="5565" data-end="5593">Non-Overlapping check</h3><p data-start="5595" data-end="5643">In this function, the overlapping check is made using disjoint assertion between all the existing regions of the task and the new one that aim to be added:</p><pre class="language-c"><code>/*@ ghost int is_disjoint = 0; */
/*@
      loop invariant 0 &lt;= idx &lt;= TASK_MAX_RESSOURCES_NUM;
      loop invariant \initialized(&amp;cell-&gt;layout[idx]);
      loop assigns idx;
      loop variant TASK_MAX_RESSOURCES_NUM - idx;
 */
for (uint8_t idx = 0; idx &lt; TASK_MAX_RESSOURCES_NUM; ++idx) {
    if (unlikely(mpu_regions_overlap(cell-&gt;layout[idx], resource) == SECURE_TRUE)) {
        status = K_ERROR_INVPARAM;
        /*@ ghost is_disjoint = 1; */
        goto err;
    }
    /*@ assert disjoint(cell-&gt;layout[idx], resource); */
}</code></pre><h3 data-start="6104" data-end="6133">Context Switch</h3><p data-start="6135" data-end="6209">At context switch, the above updated table is the lonely one used in order to map the newly scheduled task, meaning that this table is the single source of memoyr mapping configuration. This is why the lonely table writter is stricty verified.</p><div class="contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary">¬†</div><h2 data-start="1872" data-end="1904">How Frama-C coverage is used</h2><p data-start="1906" data-end="1949">Frama-C is called using both EVA and WP plugins through the following entrypoint:</p><div class="contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary">¬†</div><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><pre class="language-c"><code>int map_resource(void)
{
    /*
     * here we define unpredictable resource ID and layout,
     * to cover any possible resource structure input values, so
     * that we can demonstrate that only valid (aligned, non-overlapping)
     * resources are mapped.
     * NOTE: this do not check the resource ownership, as this is done by
     * the task manager itself.
     */
    volatile uint8_t resource_id = 0;
    volatile layout_resource_t resource;
    /*
     * call kernel startup up to task manager initialisation. This part noRTE has already
     * been demonstrated in another Frama-C test that targets kernel entrypoint directly
     */
    if (prepare_startup() != 0) {
        return -1;
    }
    /* as we do not check ownership but only mapping, we use idle task as vehicle */
    mgr_task_add_resource(mgr_task_get_idle(), resource_id, resource);
    return 0;
}</code></pre></div></div><p data-start="2028" data-end="2033">This entrypoint has¬† the following properties:</p><ul data-start="2035" data-end="2264"><li data-start="2035" data-end="2096"><p data-start="2037" data-end="2096"><code data-start="2037" data-end="2050">resource_id</code> <em data-start="2051" data-end="2066">unconstrained</em> (volatile nondeterministic)</p></li><li data-start="2097" data-end="2163"><p data-start="2099" data-end="2163"><code data-start="2099" data-end="2109">resource</code> <em data-start="2110" data-end="2125">unconstrained</em> (volatile full <code data-start="2141" data-end="2160">layout_resource_t</code>)</p></li><li data-start="2164" data-end="2264"><p data-start="2166" data-end="2264">no precondition on the shape of the descriptor or its fields</p></li></ul><p data-start="2266" data-end="2376"><strong data-start="2266" data-end="2279">Important</strong>: the test does <em data-start="2295" data-end="2300">not</em> assume anything about <code data-start="2323" data-end="2333">resource</code> ‚Äî it may hold any bit pattern. That means:</p><ul data-start="2378" data-end="2764"><li data-start="2378" data-end="2518"><p data-start="2380" data-end="2518">Frama-C‚Äôs WP plugin generates obligations for <em data-start="2426" data-end="2440">all possible</em> values of the <code data-start="2455" data-end="2474">layout_resource_t</code> inputs passed to <code data-start="2492" data-end="2515">mgr_task_add_resource</code>.</p></li><li data-start="2519" data-end="2673"><p data-start="2521" data-end="2673">As part of the manager implementation, <code data-start="2560" data-end="2583">mgr_task_add_resource</code> will <strong data-start="2589" data-end="2614">forge an MPU resource</strong> using the kernel‚Äôs internal data and architecture model.</p></li><li data-start="2674" data-end="2764"><p data-start="2676" data-end="2764">The forging logic includes those important W^X assertions inside <code data-start="2741" data-end="2761">mpu_forge_resource</code>.</p></li></ul><p data-start="2766" data-end="2939">Because those assertions are in the <em data-start="2802" data-end="2830">resource construction code</em>, the only way for the overall proof to succeed for <em data-start="2882" data-end="2932">every nondeterministic input resource descriptor</em> is if:</p><ol data-start="2941" data-end="3278"><li data-start="2941" data-end="3110"><p data-start="2944" data-end="3110"><strong data-start="2944" data-end="3019">invalid region configurations are either rejected or proven unreachable</strong> ‚Äî i.e., they violate <code data-start="3041" data-end="3062">mpu_region_is_valid</code> or internal access-permission invariants; and</p></li><li data-start="3111" data-end="3278"><p data-start="3114" data-end="3278"><strong data-start="3114" data-end="3277">only valid MPU regions that satisfy alignment, size, and access permission constraints (including W^X) can ever flow into the low-level MPU configuration logic</strong>.</p></li></ol><p data-start="3280" data-end="3556">Frama-C tries to discharge all obligations (e.g., prove no runtime errors, prove postconditions, prove assertions). If any possible value could produce a region that violates W^X (e.g., writable and executable), the corresponding WP proof obligation <em data-start="3530" data-end="3555">would not be discharged</em>.</p><p data-start="3558" data-end="3563">Thus:</p><p data-start="3565" data-end="3921">‚úî The test <em data-start="3576" data-end="3610">covers all possible bit patterns</em> for <code data-start="3615" data-end="3625">resource</code><br data-start="3625" data-end="3628">‚úî The proof infrastructure uses <code data-start="3660" data-end="3681">mpu_region_is_valid</code> to <em data-start="3685" data-end="3727">reject invalid base/limit configurations</em> via its ACSL predicate in <code data-start="3754" data-end="3769">mpu_pmsa_v8.h</code></p><p data-start="3923" data-end="3980">When launched, the <strong data-start="3930" data-end="3959">Frama-C test demonstrates</strong> the W^X property by:</p><ul data-start="3982" data-end="4272"><li data-start="3982" data-end="4122"><p data-start="3984" data-end="4122">constraining the set of acceptable region configurations to only those where <strong data-start="4061" data-end="4115">write and execute are not simultaneously permitted</strong>; and</p></li><li data-start="4123" data-end="4272"><p data-start="4125" data-end="4272">ensuring that any path through <code data-start="4156" data-end="4179">mgr_task_add_resource</code> that could lead to invalid combinations <em data-start="4220" data-end="4271">cannot happen under the ACSL and proof conditions</em>.</p></li></ul><p>Test results show that Frama-C is able to demonstrate that all assertions and obligations are valid, whatever the input is, and as such demonstrate the effective W^X property.</p><h2 data-start="7318" data-end="7331">Conclusion</h2><p data-start="7333" data-end="7540">Sentry demonstrates that formal verification is not an abstract academic ideal, but a <strong data-start="7419" data-end="7449">practical engineering tool</strong> for building secure micro-kernels. Nowhere is this more concrete than in its MPU subsystem:</p><ul data-start="7542" data-end="7716"><li data-start="7542" data-end="7607"><p data-start="7544" data-end="7607">Memory isolation is backed by mathematically proven invariants.</p></li><li data-start="7608" data-end="7658"><p data-start="7610" data-end="7658">Subtle, low-level bugs are eliminated by design.</p></li><li data-start="7659" data-end="7716"><p data-start="7661" data-end="7716">Security properties are guaranteed rather than assumed.</p></li></ul><p data-start="7718" data-end="7876">By integrating formal methods into both architecture and implementation, Sentry raises the bar for what it means to be ‚Äúsecure by design‚Äù in embedded systems.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on January 30, 2026</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://camelot-os.h2lab.org/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcamelot-os.h2lab.org%2Fwhy-formal-verification-matters-in-the-sentry-microkernel%2F" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://camelot-os.h2lab.org/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://camelot-os.h2lab.org/authors/h2lab-development-team/" rel="author">H2Lab Development Team</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://camelot-os.h2lab.org/exploring-pointer-free-data-exchange-in-sentry/" class="content__nav-link" rel="prev"><div><span>Previous</span> Exploring Pointer-Free Data Exchange in Sentry</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><time datetime="2026-01-17T16:10" class="feed__date">January 17, 2026</time></div><h3 class="feed__title"><a href="https://camelot-os.h2lab.org/exploring-pointer-free-data-exchange-in-sentry/">Exploring Pointer-Free Data Exchange in Sentry</a></h3></header><p>When diving into Sentry-micro-kernel concepts, one design choice really stood out: no pointer passing between user space and kernel space. Instead of relying on pointers, Sentry uses a dedicated buffer called svc_exchange to transfer data between applications and the kernel. This simple but powerful approach:&hellip;</p><a href="https://camelot-os.h2lab.org/exploring-pointer-free-data-exchange-in-sentry/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><time datetime="2026-01-17T16:12" class="feed__date">January 17, 2026</time></div><h3 class="feed__title"><a href="https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-3/">Formal proof in embedded systems part 3</a></h3></header><p>Alongside noRTE coverage, the Sentry kernel aims to hold functional proofs for its critical functions. One of them is the memory management part, that is responsible to ensure the W^X property of all memory regions mapped, for both kernel an user tasks. This work has&hellip;</p><a href="https://camelot-os.h2lab.org/formal-proof-in-embedded-systems-part-3/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><time datetime="2026-01-17T12:15" class="feed__date">January 17, 2026</time></div><h3 class="feed__title"><a href="https://camelot-os.h2lab.org/sentry-kernel-key-concepts-part-1-basics/">Sentry Kernel key concepts part 1: Basics</a></h3></header><p>When it comes to embedded systems, security and reliability aren‚Äôt just features‚Äîthey‚Äôre requirements. That‚Äôs why we built the Sentry Kernel, a preemptive micro-kernel designed for micro-controllers, with security baked in from the ground up. üîë Key Highlights: Minimal attack surface: Only critical devices (like DMA)&hellip;</p><a href="https://camelot-os.h2lab.org/sentry-kernel-key-concepts-part-1-basics/" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>A H2Lab project</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://camelot-os.h2lab.org/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://camelot-os.h2lab.org/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://camelot-os.h2lab.org/media/plugins/syntaxHighlighter/prism.js"></script><script defer="defer" src="https://camelot-os.h2lab.org/media/plugins/syntaxHighlighter/prism-inline-color.min.js"></script><script>(function() {
					let collapsibleTOCItems = document.querySelectorAll(".post__toc h2");

					collapsibleTOCItems.forEach(function(item, index) {
						let subList = item.nextElementSibling;
						let parentItem = item.parentElement;
						let toggleButton = null;

						if (subList && subList.tagName === "OL") {
						let defaultState = 'false';
						parentItem.setAttribute('aria-expanded', defaultState);
						subList.setAttribute('aria-hidden', defaultState === 'true' ? 'false' : 'true');

						// Assign ID to subList
						subList.setAttribute('id', 'sublist-' + index);

						const toggleElement = "both";

						if (toggleElement === "header" || toggleElement === "both") {
							// Assign aria-controls and tabindex to item (header)
							item.setAttribute('aria-controls', 'sublist-' + index);
							item.setAttribute('tabindex', '0');

							item.addEventListener('click', function(event) {
								event.preventDefault();
								toggleSubList(this, toggleButton);
							});

							item.addEventListener('keydown', function(event) {
								if (event.key === 'Enter' || event.key === ' ') {
								event.preventDefault();
								toggleSubList(this, toggleButton);
								}
							});
						}

						if (toggleElement === "button" || toggleElement === "both") {
							toggleButton = item.querySelector('.post__toc-toggle');
							if (toggleButton) {
								// Assign aria-controls and tabindex to toggleButton
								toggleButton.setAttribute('aria-controls', 'sublist-' + index);
								toggleButton.setAttribute('tabindex', '0');
								toggleButton.textContent = defaultState === 'true' ? 'hide' : 'show';
								toggleButton.addEventListener('click', function(event) {
								event.stopPropagation();
								event.preventDefault();
								toggleSubList(item, toggleButton);
								});
							}
						}
						}
					});

					function toggleSubList(element, button) {
						let parentItem = element.parentElement;
						let subList = parentItem.querySelector('ol');

						if (subList) {
						if (parentItem.getAttribute('aria-expanded') === 'true') {
							parentItem.setAttribute('aria-expanded', 'false');
							subList.setAttribute('aria-hidden', 'true');
						} else {
							parentItem.setAttribute('aria-expanded', 'true');
							subList.setAttribute('aria-hidden', 'false');
						}
						}

						if (button) {
						button.textContent = parentItem.getAttribute('aria-expanded') === 'true' ? 'hide' : 'show';
						}
					}
				})();</script></body></html>